// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

// Disable clippy warnings that can result in the way how parol generates code.
#![allow(clippy::enum_variant_names)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::upper_case_acronyms)]

use parol_runtime::derive_builder::Builder;
use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::parser::{ParseTreeType, UserActionsTrait};
use parol_runtime::{ParserError, Result, Token};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait WikiGrammarTrait<'t> {
    /// Semantic action for non-terminal 'Wiki'
    fn wiki(&mut self, _arg: &Wiki<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Link'
    fn link(&mut self, _arg: &Link<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Attribute'
    fn attribute(&mut self, _arg: &Attribute<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Attribute2'
    fn attribute2(&mut self, _arg: &Attribute2<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LCurlyPipe'
    fn l_curly_pipe(&mut self, _arg: &LCurlyPipe<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RCurlyPipe'
    fn r_curly_pipe(&mut self, _arg: &RCurlyPipe<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LSquare'
    fn l_square(&mut self, _arg: &LSquare<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RSquare'
    fn r_square(&mut self, _arg: &RSquare<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LCurly'
    fn l_curly(&mut self, _arg: &LCurly<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RCurly'
    fn r_curly(&mut self, _arg: &RCurly<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Pipe'
    fn pipe(&mut self, _arg: &Pipe<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RawString'
    fn raw_string(&mut self, _arg: &RawString<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'String'
    fn string(&mut self, _arg: &String<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Value'
    fn value(&mut self, _arg: &Value<'t>) -> Result<()> {
        Ok(())
    }

    /// This method provides skipped language comments.
    /// If you need comments please provide your own implementation of this method.
    fn on_comment_parsed(&mut self, _token: Token<'t>) {}
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 9
///
/// `Attribute2ListGroup: RawString;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Attribute2ListGroupRawString<'t> {
    pub raw_string: Box<RawString<'t>>,
}

///
/// Type derived for production 10
///
/// `Attribute2ListGroup: Pipe;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Attribute2ListGroupPipe<'t> {
    pub pipe: Box<Pipe<'t>>,
}

///
/// Type derived for production 11
///
/// `Attribute2ListGroup: String;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Attribute2ListGroupString<'t> {
    pub string: Box<String<'t>>,
}

///
/// Type derived for production 12
///
/// `Attribute2ListGroup: LCurly;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Attribute2ListGroupLCurly<'t> {
    pub l_curly: Box<LCurly<'t>>,
}

///
/// Type derived for production 13
///
/// `Attribute2ListGroup: RCurly;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Attribute2ListGroupRCurly<'t> {
    pub r_curly: Box<RCurly<'t>>,
}

///
/// Type derived for production 14
///
/// `Attribute2ListGroup: LSquare;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Attribute2ListGroupLSquare<'t> {
    pub l_square: Box<LSquare<'t>>,
}

///
/// Type derived for production 15
///
/// `Attribute2ListGroup: RSquare;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Attribute2ListGroupRSquare<'t> {
    pub r_square: Box<RSquare<'t>>,
}

///
/// Type derived for production 28
///
/// `ValueListGroup: Link;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValueListGroupLink<'t> {
    pub link: Box<Link<'t>>,
}

///
/// Type derived for production 29
///
/// `ValueListGroup: Attribute;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValueListGroupAttribute<'t> {
    pub attribute: Box<Attribute<'t>>,
}

///
/// Type derived for production 30
///
/// `ValueListGroup: Attribute2;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValueListGroupAttribute2<'t> {
    pub attribute2: Box<Attribute2<'t>>,
}

///
/// Type derived for production 31
///
/// `ValueListGroup: String;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValueListGroupString<'t> {
    pub string: Box<String<'t>>,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal Attribute
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Attribute<'t> {
    pub l_curly: Box<LCurly<'t>>,
    pub string: Box<String<'t>>,
    pub attribute_list: Vec<AttributeList<'t>>,
    pub r_curly: Box<RCurly<'t>>,
}

///
/// Type derived for non-terminal Attribute2
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Attribute2<'t> {
    pub l_curly_pipe: Box<LCurlyPipe<'t>>,
    pub attribute2_list: Vec<Attribute2List<'t>>,
    pub r_curly_pipe: Box<RCurlyPipe<'t>>,
}

///
/// Type derived for non-terminal Attribute2List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Attribute2List<'t> {
    pub attribute2_list_group: Box<Attribute2ListGroup<'t>>,
}

///
/// Type derived for non-terminal Attribute2ListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Attribute2ListGroup<'t> {
    RawString(Attribute2ListGroupRawString<'t>),
    Pipe(Attribute2ListGroupPipe<'t>),
    String(Attribute2ListGroupString<'t>),
    LCurly(Attribute2ListGroupLCurly<'t>),
    RCurly(Attribute2ListGroupRCurly<'t>),
    LSquare(Attribute2ListGroupLSquare<'t>),
    RSquare(Attribute2ListGroupRSquare<'t>),
}

///
/// Type derived for non-terminal AttributeList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AttributeList<'t> {
    pub pipe: Box<Pipe<'t>>,
    pub value: Box<Value<'t>>,
}

///
/// Type derived for non-terminal LCurly
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LCurly<'t> {
    pub l_curly: Token<'t>, /* {{ */
}

///
/// Type derived for non-terminal LCurlyPipe
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LCurlyPipe<'t> {
    pub l_curly_pipe: Token<'t>, /* {| */
}

///
/// Type derived for non-terminal LSquare
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LSquare<'t> {
    pub l_square: Token<'t>, /* [[ */
}

///
/// Type derived for non-terminal Link
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Link<'t> {
    pub l_square: Box<LSquare<'t>>,
    pub string: Box<String<'t>>,
    pub link_list: Vec<LinkList<'t>>,
    pub r_square: Box<RSquare<'t>>,
}

///
/// Type derived for non-terminal LinkList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LinkList<'t> {
    pub pipe: Box<Pipe<'t>>,
    pub value: Box<Value<'t>>,
}

///
/// Type derived for non-terminal Pipe
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Pipe<'t> {
    pub pipe: Token<'t>, /* | */
}

///
/// Type derived for non-terminal RCurly
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RCurly<'t> {
    pub r_curly: Token<'t>, /* }} */
}

///
/// Type derived for non-terminal RCurlyPipe
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RCurlyPipe<'t> {
    pub r_curly_pipe: Token<'t>, /* |} */
}

///
/// Type derived for non-terminal RSquare
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RSquare<'t> {
    pub r_square: Token<'t>, /* ]] */
}

///
/// Type derived for non-terminal RawString
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RawString<'t> {
    pub raw_string: Token<'t>, /* [^(\|\})(\{\|)]* */
}

///
/// Type derived for non-terminal String
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct String<'t> {
    pub string: Token<'t>, /* (\.|[^\[\]\{\}\|])* */
}

///
/// Type derived for non-terminal Value
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Value<'t> {
    pub value_list: Vec<ValueList<'t>>,
}

///
/// Type derived for non-terminal ValueList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValueList<'t> {
    pub value_list_group: Box<ValueListGroup<'t>>,
}

///
/// Type derived for non-terminal ValueListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ValueListGroup<'t> {
    Link(ValueListGroupLink<'t>),
    Attribute(ValueListGroupAttribute<'t>),
    Attribute2(ValueListGroupAttribute2<'t>),
    String(ValueListGroupString<'t>),
}

///
/// Type derived for non-terminal Wiki
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Wiki<'t> {
    pub value: Box<Value<'t>>,
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    Attribute(Attribute<'t>),
    Attribute2(Attribute2<'t>),
    Attribute2List(Vec<Attribute2List<'t>>),
    Attribute2ListGroup(Attribute2ListGroup<'t>),
    AttributeList(Vec<AttributeList<'t>>),
    LCurly(LCurly<'t>),
    LCurlyPipe(LCurlyPipe<'t>),
    LSquare(LSquare<'t>),
    Link(Link<'t>),
    LinkList(Vec<LinkList<'t>>),
    Pipe(Pipe<'t>),
    RCurly(RCurly<'t>),
    RCurlyPipe(RCurlyPipe<'t>),
    RSquare(RSquare<'t>),
    RawString(RawString<'t>),
    String(String<'t>),
    Value(Value<'t>),
    ValueList(Vec<ValueList<'t>>),
    ValueListGroup(ValueListGroup<'t>),
    Wiki(Wiki<'t>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct WikiGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn WikiGrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
}

///
/// The `WikiGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> WikiGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn WikiGrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        let item = self.item_stack.pop();
        if let Some(ref item) = item {
            trace!("pop     {}: {:?}", context, item);
        }
        item
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// `Wiki: Value;`
    ///
    #[parol_runtime::function_name::named]
    fn wiki(&mut self, _value: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let value = pop_item!(self, value, Value, context);
        let wiki_built = Wiki {
            value: Box::new(value),
        };
        // Calling user action here
        self.user_grammar.wiki(&wiki_built)?;
        self.push(ASTType::Wiki(wiki_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// `Link: LSquare String LinkList /* Vec */ RSquare;`
    ///
    #[parol_runtime::function_name::named]
    fn link(
        &mut self,
        _l_square: &ParseTreeType<'t>,
        _string: &ParseTreeType<'t>,
        _link_list: &ParseTreeType<'t>,
        _r_square: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_square = pop_item!(self, r_square, RSquare, context);
        let link_list = pop_and_reverse_item!(self, link_list, LinkList, context);
        let string = pop_item!(self, string, String, context);
        let l_square = pop_item!(self, l_square, LSquare, context);
        let link_built = Link {
            l_square: Box::new(l_square),
            string: Box::new(string),
            link_list,
            r_square: Box::new(r_square),
        };
        // Calling user action here
        self.user_grammar.link(&link_built)?;
        self.push(ASTType::Link(link_built), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// `LinkList /* Vec<T>::Push */: Pipe Value LinkList;`
    ///
    #[parol_runtime::function_name::named]
    fn link_list_0(
        &mut self,
        _pipe: &ParseTreeType<'t>,
        _value: &ParseTreeType<'t>,
        _link_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut link_list = pop_item!(self, link_list, LinkList, context);
        let value = pop_item!(self, value, Value, context);
        let pipe = pop_item!(self, pipe, Pipe, context);
        let link_list_0_built = LinkList {
            value: Box::new(value),
            pipe: Box::new(pipe),
        };
        // Add an element to the vector
        link_list.push(link_list_0_built);
        self.push(ASTType::LinkList(link_list), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// `LinkList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn link_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let link_list_1_built = Vec::new();
        self.push(ASTType::LinkList(link_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// `Attribute: LCurly String AttributeList /* Vec */ RCurly;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute(
        &mut self,
        _l_curly: &ParseTreeType<'t>,
        _string: &ParseTreeType<'t>,
        _attribute_list: &ParseTreeType<'t>,
        _r_curly: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_curly = pop_item!(self, r_curly, RCurly, context);
        let attribute_list = pop_and_reverse_item!(self, attribute_list, AttributeList, context);
        let string = pop_item!(self, string, String, context);
        let l_curly = pop_item!(self, l_curly, LCurly, context);
        let attribute_built = Attribute {
            l_curly: Box::new(l_curly),
            string: Box::new(string),
            attribute_list,
            r_curly: Box::new(r_curly),
        };
        // Calling user action here
        self.user_grammar.attribute(&attribute_built)?;
        self.push(ASTType::Attribute(attribute_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// `AttributeList /* Vec<T>::Push */: Pipe Value AttributeList;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute_list_0(
        &mut self,
        _pipe: &ParseTreeType<'t>,
        _value: &ParseTreeType<'t>,
        _attribute_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut attribute_list = pop_item!(self, attribute_list, AttributeList, context);
        let value = pop_item!(self, value, Value, context);
        let pipe = pop_item!(self, pipe, Pipe, context);
        let attribute_list_0_built = AttributeList {
            value: Box::new(value),
            pipe: Box::new(pipe),
        };
        // Add an element to the vector
        attribute_list.push(attribute_list_0_built);
        self.push(ASTType::AttributeList(attribute_list), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// `AttributeList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let attribute_list_1_built = Vec::new();
        self.push(ASTType::AttributeList(attribute_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// `Attribute2: LCurlyPipe Attribute2List /* Vec */ RCurlyPipe;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute2(
        &mut self,
        _l_curly_pipe: &ParseTreeType<'t>,
        _attribute2_list: &ParseTreeType<'t>,
        _r_curly_pipe: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_curly_pipe = pop_item!(self, r_curly_pipe, RCurlyPipe, context);
        let attribute2_list = pop_and_reverse_item!(self, attribute2_list, Attribute2List, context);
        let l_curly_pipe = pop_item!(self, l_curly_pipe, LCurlyPipe, context);
        let attribute2_built = Attribute2 {
            l_curly_pipe: Box::new(l_curly_pipe),
            attribute2_list,
            r_curly_pipe: Box::new(r_curly_pipe),
        };
        // Calling user action here
        self.user_grammar.attribute2(&attribute2_built)?;
        self.push(ASTType::Attribute2(attribute2_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// `Attribute2List /* Vec<T>::Push */: Attribute2ListGroup Attribute2List;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute2_list_0(
        &mut self,
        _attribute2_list_group: &ParseTreeType<'t>,
        _attribute2_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut attribute2_list = pop_item!(self, attribute2_list, Attribute2List, context);
        let attribute2_list_group =
            pop_item!(self, attribute2_list_group, Attribute2ListGroup, context);
        let attribute2_list_0_built = Attribute2List {
            attribute2_list_group: Box::new(attribute2_list_group),
        };
        // Add an element to the vector
        attribute2_list.push(attribute2_list_0_built);
        self.push(ASTType::Attribute2List(attribute2_list), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// `Attribute2ListGroup: RawString;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute2_list_group_0(&mut self, _raw_string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string = pop_item!(self, raw_string, RawString, context);
        let attribute2_list_group_0_built = Attribute2ListGroupRawString {
            raw_string: Box::new(raw_string),
        };
        let attribute2_list_group_0_built =
            Attribute2ListGroup::RawString(attribute2_list_group_0_built);
        self.push(
            ASTType::Attribute2ListGroup(attribute2_list_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// `Attribute2ListGroup: Pipe;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute2_list_group_1(&mut self, _pipe: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let pipe = pop_item!(self, pipe, Pipe, context);
        let attribute2_list_group_1_built = Attribute2ListGroupPipe {
            pipe: Box::new(pipe),
        };
        let attribute2_list_group_1_built =
            Attribute2ListGroup::Pipe(attribute2_list_group_1_built);
        self.push(
            ASTType::Attribute2ListGroup(attribute2_list_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// `Attribute2ListGroup: String;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute2_list_group_2(&mut self, _string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = pop_item!(self, string, String, context);
        let attribute2_list_group_2_built = Attribute2ListGroupString {
            string: Box::new(string),
        };
        let attribute2_list_group_2_built =
            Attribute2ListGroup::String(attribute2_list_group_2_built);
        self.push(
            ASTType::Attribute2ListGroup(attribute2_list_group_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// `Attribute2ListGroup: LCurly;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute2_list_group_3(&mut self, _l_curly: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_curly = pop_item!(self, l_curly, LCurly, context);
        let attribute2_list_group_3_built = Attribute2ListGroupLCurly {
            l_curly: Box::new(l_curly),
        };
        let attribute2_list_group_3_built =
            Attribute2ListGroup::LCurly(attribute2_list_group_3_built);
        self.push(
            ASTType::Attribute2ListGroup(attribute2_list_group_3_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// `Attribute2ListGroup: RCurly;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute2_list_group_4(&mut self, _r_curly: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_curly = pop_item!(self, r_curly, RCurly, context);
        let attribute2_list_group_4_built = Attribute2ListGroupRCurly {
            r_curly: Box::new(r_curly),
        };
        let attribute2_list_group_4_built =
            Attribute2ListGroup::RCurly(attribute2_list_group_4_built);
        self.push(
            ASTType::Attribute2ListGroup(attribute2_list_group_4_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// `Attribute2ListGroup: LSquare;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute2_list_group_5(&mut self, _l_square: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_square = pop_item!(self, l_square, LSquare, context);
        let attribute2_list_group_5_built = Attribute2ListGroupLSquare {
            l_square: Box::new(l_square),
        };
        let attribute2_list_group_5_built =
            Attribute2ListGroup::LSquare(attribute2_list_group_5_built);
        self.push(
            ASTType::Attribute2ListGroup(attribute2_list_group_5_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// `Attribute2ListGroup: RSquare;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute2_list_group_6(&mut self, _r_square: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_square = pop_item!(self, r_square, RSquare, context);
        let attribute2_list_group_6_built = Attribute2ListGroupRSquare {
            r_square: Box::new(r_square),
        };
        let attribute2_list_group_6_built =
            Attribute2ListGroup::RSquare(attribute2_list_group_6_built);
        self.push(
            ASTType::Attribute2ListGroup(attribute2_list_group_6_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// `Attribute2List /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute2_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let attribute2_list_1_built = Vec::new();
        self.push(ASTType::Attribute2List(attribute2_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// `LCurlyPipe: '{|';`
    ///
    #[parol_runtime::function_name::named]
    fn l_curly_pipe(&mut self, l_curly_pipe: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_curly_pipe = l_curly_pipe.token()?.clone();
        let l_curly_pipe_built = LCurlyPipe { l_curly_pipe };
        // Calling user action here
        self.user_grammar.l_curly_pipe(&l_curly_pipe_built)?;
        self.push(ASTType::LCurlyPipe(l_curly_pipe_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// `RCurlyPipe: '|}';`
    ///
    #[parol_runtime::function_name::named]
    fn r_curly_pipe(&mut self, r_curly_pipe: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_curly_pipe = r_curly_pipe.token()?.clone();
        let r_curly_pipe_built = RCurlyPipe { r_curly_pipe };
        // Calling user action here
        self.user_grammar.r_curly_pipe(&r_curly_pipe_built)?;
        self.push(ASTType::RCurlyPipe(r_curly_pipe_built), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// `LSquare: '[[';`
    ///
    #[parol_runtime::function_name::named]
    fn l_square(&mut self, l_square: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_square = l_square.token()?.clone();
        let l_square_built = LSquare { l_square };
        // Calling user action here
        self.user_grammar.l_square(&l_square_built)?;
        self.push(ASTType::LSquare(l_square_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// `RSquare: ']]';`
    ///
    #[parol_runtime::function_name::named]
    fn r_square(&mut self, r_square: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_square = r_square.token()?.clone();
        let r_square_built = RSquare { r_square };
        // Calling user action here
        self.user_grammar.r_square(&r_square_built)?;
        self.push(ASTType::RSquare(r_square_built), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// `LCurly: '{{';`
    ///
    #[parol_runtime::function_name::named]
    fn l_curly(&mut self, l_curly: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_curly = l_curly.token()?.clone();
        let l_curly_built = LCurly { l_curly };
        // Calling user action here
        self.user_grammar.l_curly(&l_curly_built)?;
        self.push(ASTType::LCurly(l_curly_built), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// `RCurly: '}}';`
    ///
    #[parol_runtime::function_name::named]
    fn r_curly(&mut self, r_curly: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_curly = r_curly.token()?.clone();
        let r_curly_built = RCurly { r_curly };
        // Calling user action here
        self.user_grammar.r_curly(&r_curly_built)?;
        self.push(ASTType::RCurly(r_curly_built), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// `Pipe: '|';`
    ///
    #[parol_runtime::function_name::named]
    fn pipe(&mut self, pipe: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let pipe = pipe.token()?.clone();
        let pipe_built = Pipe { pipe };
        // Calling user action here
        self.user_grammar.pipe(&pipe_built)?;
        self.push(ASTType::Pipe(pipe_built), context);
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// `RawString: <ForRawString>/[^(\|\})(\{\|)]*/;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string(&mut self, raw_string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string = raw_string.token()?.clone();
        let raw_string_built = RawString { raw_string };
        // Calling user action here
        self.user_grammar.raw_string(&raw_string_built)?;
        self.push(ASTType::RawString(raw_string_built), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// `String: /(\.|[^\[\]\{\}\|])*/;`
    ///
    #[parol_runtime::function_name::named]
    fn string(&mut self, string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = string.token()?.clone();
        let string_built = String { string };
        // Calling user action here
        self.user_grammar.string(&string_built)?;
        self.push(ASTType::String(string_built), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// `Value: ValueList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn value(&mut self, _value_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let value_list = pop_and_reverse_item!(self, value_list, ValueList, context);
        let value_built = Value { value_list };
        // Calling user action here
        self.user_grammar.value(&value_built)?;
        self.push(ASTType::Value(value_built), context);
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// `ValueList /* Vec<T>::Push */: ValueListGroup ValueList;`
    ///
    #[parol_runtime::function_name::named]
    fn value_list_0(
        &mut self,
        _value_list_group: &ParseTreeType<'t>,
        _value_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut value_list = pop_item!(self, value_list, ValueList, context);
        let value_list_group = pop_item!(self, value_list_group, ValueListGroup, context);
        let value_list_0_built = ValueList {
            value_list_group: Box::new(value_list_group),
        };
        // Add an element to the vector
        value_list.push(value_list_0_built);
        self.push(ASTType::ValueList(value_list), context);
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// `ValueListGroup: Link;`
    ///
    #[parol_runtime::function_name::named]
    fn value_list_group_0(&mut self, _link: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let link = pop_item!(self, link, Link, context);
        let value_list_group_0_built = ValueListGroupLink {
            link: Box::new(link),
        };
        let value_list_group_0_built = ValueListGroup::Link(value_list_group_0_built);
        self.push(ASTType::ValueListGroup(value_list_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// `ValueListGroup: Attribute;`
    ///
    #[parol_runtime::function_name::named]
    fn value_list_group_1(&mut self, _attribute: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let attribute = pop_item!(self, attribute, Attribute, context);
        let value_list_group_1_built = ValueListGroupAttribute {
            attribute: Box::new(attribute),
        };
        let value_list_group_1_built = ValueListGroup::Attribute(value_list_group_1_built);
        self.push(ASTType::ValueListGroup(value_list_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// `ValueListGroup: Attribute2;`
    ///
    #[parol_runtime::function_name::named]
    fn value_list_group_2(&mut self, _attribute2: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let attribute2 = pop_item!(self, attribute2, Attribute2, context);
        let value_list_group_2_built = ValueListGroupAttribute2 {
            attribute2: Box::new(attribute2),
        };
        let value_list_group_2_built = ValueListGroup::Attribute2(value_list_group_2_built);
        self.push(ASTType::ValueListGroup(value_list_group_2_built), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// `ValueListGroup: String;`
    ///
    #[parol_runtime::function_name::named]
    fn value_list_group_3(&mut self, _string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = pop_item!(self, string, String, context);
        let value_list_group_3_built = ValueListGroupString {
            string: Box::new(string),
        };
        let value_list_group_3_built = ValueListGroup::String(value_list_group_3_built);
        self.push(ASTType::ValueListGroup(value_list_group_3_built), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// `ValueList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn value_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let value_list_1_built = Vec::new();
        self.push(ASTType::ValueList(value_list_1_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for WikiGrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item WikiGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeType<'t>],
    ) -> Result<()> {
        match prod_num {
            0 => self.wiki(&children[0]),
            1 => self.link(&children[0], &children[1], &children[2], &children[3]),
            2 => self.link_list_0(&children[0], &children[1], &children[2]),
            3 => self.link_list_1(),
            4 => self.attribute(&children[0], &children[1], &children[2], &children[3]),
            5 => self.attribute_list_0(&children[0], &children[1], &children[2]),
            6 => self.attribute_list_1(),
            7 => self.attribute2(&children[0], &children[1], &children[2]),
            8 => self.attribute2_list_0(&children[0], &children[1]),
            9 => self.attribute2_list_group_0(&children[0]),
            10 => self.attribute2_list_group_1(&children[0]),
            11 => self.attribute2_list_group_2(&children[0]),
            12 => self.attribute2_list_group_3(&children[0]),
            13 => self.attribute2_list_group_4(&children[0]),
            14 => self.attribute2_list_group_5(&children[0]),
            15 => self.attribute2_list_group_6(&children[0]),
            16 => self.attribute2_list_1(),
            17 => self.l_curly_pipe(&children[0]),
            18 => self.r_curly_pipe(&children[0]),
            19 => self.l_square(&children[0]),
            20 => self.r_square(&children[0]),
            21 => self.l_curly(&children[0]),
            22 => self.r_curly(&children[0]),
            23 => self.pipe(&children[0]),
            24 => self.raw_string(&children[0]),
            25 => self.string(&children[0]),
            26 => self.value(&children[0]),
            27 => self.value_list_0(&children[0], &children[1]),
            28 => self.value_list_group_0(&children[0]),
            29 => self.value_list_group_1(&children[0]),
            30 => self.value_list_group_2(&children[0]),
            31 => self.value_list_group_3(&children[0]),
            32 => self.value_list_1(),
            _ => Err(ParserError::InternalError(format!(
                "Unhandled production number: {}",
                prod_num
            ))
            .into()),
        }
    }

    fn on_comment_parsed(&mut self, token: Token<'t>) {
        self.user_grammar.on_comment_parsed(token)
    }
}
